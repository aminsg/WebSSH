@page "/Shell/{UniqueId:guid}"
@inject HttpClient Http
@inject NavigationManager NavManager
@inject IJSRuntime JSRuntime;

<h3>Shell</h3>

<div class="row">
    <div class="form-group col-md-12">
        <label for="CommandText">Shell Output</label>
        <textarea class="form-control" id="ShellOutput" style="height:26em" readonly>@ResultString</textarea>
    </div>
    <div class="form-group col-md-2">
        <label for="CommandMode">Command Mode</label>
        <select class="form-control" id="CommandMode" @bind="@CommandMode">
            <option value="0">Single Line</option>
            <option value="1">Multi Lines</option>
        </select>
    </div>
    <div class="form-group  col-md-10">
        <label for="CommandText">Command Content</label>
        @if (CommandMode == 0)
        {
            <input type="text" class="form-control" autocomplete="off" id="CommandText" @onkeydown="@OnCommandKeydown" @bind-value="@Command" @bind-value:event="oninput">
        }
        else
        {
            <textarea id="CommandText" class="form-control" @bind="@Command" @bind:event="oninput"></textarea>
        }
    </div>
    <div class="form-group  col-md-12">
        <button type="button" class="btn btn-primary" @onclick="@RunCommand">Run Command</button>
        <button type="button" class="btn btn-danger" @onclick="@Clear">Clear</button>
    </div>
</div>

@code{

    [Parameter]
    public Guid UniqueId { get; set; }

    public int CommandMode { get; set; }

    string resultString = string.Empty;

    static Task task;
    static System.Threading.CancellationTokenSource cancellationTokenSource;
    public string Command { get; set; } = string.Empty;
    public string ResultString => StaticUtils.GetOutputString(UniqueId);

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        ScrollToBottom();

        if (firstRender)
        {
            try
            {
                cancellationTokenSource?.Cancel();
                cancellationTokenSource?.Dispose();
                cancellationTokenSource = null;

                if (task != null)
                {
                    try
                    {
                        await task;

                    }
                    catch (TaskCanceledException)
                    {
                        // Ignore
                    }

                    task.Dispose();
                    task = null;
                }

                var isConnected = await Http.GetFromJsonAsync<ServerResponse<bool>>("/api/Shell/IsConnected?uniqueId=" + UniqueId);

                if (isConnected.Response)
                {
                    cancellationTokenSource = new System.Threading.CancellationTokenSource();
                    var token = cancellationTokenSource.Token;

                    task = Task.Run(async () =>
                    {
                        while (true)
                        {
                            token.ThrowIfCancellationRequested();

                            var needGetLinesRightNow = false;
                            var response = await Http.GetFromJsonAsync<ServerResponse<ServerOutput>>("/api/Shell/GetShellOutput?uniqueId=" + UniqueId, token);
                            if (response.StausResult == StausResult.Successful)
                            {
                                if (!string.IsNullOrEmpty(response.Response.Output))
                                {
                                    StaticUtils.AddOutputString(UniqueId, response.Response.Output);
                                    StateHasChanged();

                                    if (response.Response.Lines == Constants.MaxinumLines)
                                    {
                                        needGetLinesRightNow = true;
                                    }
                                }
                            }
                            else
                            {
                                StaticUtils.AddOutputString(UniqueId, Environment.NewLine + response.ExtraMessage);
                                StateHasChanged();

                                if (response.StausResult == StausResult.Exception)
                                {
                                    cancellationTokenSource.Cancel();
                                }
                            }

                            if (needGetLinesRightNow)
                            {
                                await Task.Delay(100, token);
                            }
                            else
                            {
                                await Task.Delay(1000, token);
                            }
                        }
                    }, token);
                }
                else
                {
                    StaticUtils.AddOutputString(UniqueId, Environment.NewLine + "Not connected");
                }
            }
            catch (Exception ex)
            {
                StaticUtils.AddOutputString(UniqueId, Environment.NewLine + ex.Message);
                StateHasChanged();
            }
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
    }

    bool IsRunningCommand { get; set; }

    async void RunCommand()
    {
        if (IsRunningCommand)
        {
            StaticUtils.AddOutputString(UniqueId, Environment.NewLine + "Is running command, please wait for pre-command finished");
            StateHasChanged();
            return;
        }

        IsRunningCommand = true;

        try
        {
            var content = await Http.GetAsync("/api/Shell/RunShellCommand?command=" + System.Web.HttpUtility.UrlEncode(Command) + "&uniqueId=" + UniqueId);
            if (content.IsSuccessStatusCode)
            {
                var response = await content.Content.ReadFromJsonAsync<ServerResponse<bool>>();

                if (response.StausResult != StausResult.Successful || !response.Response)
                {
                    StaticUtils.AddOutputString(UniqueId, Environment.NewLine + response.ExtraMessage);
                }
            }
            else
            {
                await JSRuntime.InvokeVoidAsync("ShowNotLogin", "Not login");
                NavManager.NavigateTo("/Login");
            }
        }
        catch (Exception ex)
        {
            StaticUtils.AddOutputString(UniqueId, Environment.NewLine + ex.Message);
        }

        IsRunningCommand = false;
        Command = string.Empty;
        StateHasChanged();
    }

    void Clear()
    {
        Command = string.Empty;
        StaticUtils.ClearOutputString(UniqueId);
    }

    void OnCommandKeydown(KeyboardEventArgs args)
    {
        if (args.Key == "Enter")
        {
            RunCommand();
        }
    }

    async void ScrollToBottom()
    {
        await JSRuntime.InvokeVoidAsync("ScrollToBottom", "ShellOutput");
    }
}